{
    "paper_id": "878fe008ad22db3e24216455dae235736bd0f251",
    "metadata": {
        "title": "An Abstract Contract Theory for Programs with Procedures",
        "authors": [
            {
                "first": "Christian",
                "middle": [],
                "last": "Lidstr\u00f6m",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "KTH Royal Institute of Technology",
                    "location": {
                        "settlement": "Stockholm",
                        "country": "Sweden"
                    }
                },
                "email": ""
            },
            {
                "first": "Dilian",
                "middle": [],
                "last": "Gurov",
                "suffix": "",
                "affiliation": {
                    "laboratory": "",
                    "institution": "KTH Royal Institute of Technology",
                    "location": {
                        "settlement": "Stockholm",
                        "country": "Sweden"
                    }
                },
                "email": "dilian@kth.se"
            }
        ]
    },
    "abstract": [
        {
            "text": "When developing complex software and systems, contracts provide a means for controlling the complexity by dividing the responsibilities among the components of the system in a hierarchical fashion. In specific application areas, dedicated contract theories formalise the notion of contract and the operations on contracts in a manner that supports best the development of systems in that area. At the other end, contract meta-theories attempt to provide a systematic view on the various contract theories by axiomatising their desired properties. However, there exists a noticeable gap between the most well-known contract metatheory of Benveniste et al. [5] , which focuses on the design of embedded and cyber-physical systems, and the established way of using contracts when developing general software, following Meyer's design-by-contract methodology [18] . At the core of this gap appears to be the notion of procedure: while it is a central unit of composition in software development, the meta-theory does not suggest an obvious way of treating procedures as components.",
            "cite_spans": [
                {
                    "start": 655,
                    "end": 658,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 855,
                    "end": 859,
                    "text": "[18]",
                    "ref_id": "BIBREF19"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "In this paper, we provide a first step towards a contract theory that takes procedures as the basic building block, and is at the same time an instantiation of the meta-theory. To this end, we propose an abstract contract theory for sequential programming languages with procedures, based on denotational semantics. We show that, on the one hand, the specification of contracts of procedures in Hoare logic, and their procedure-modular verification, can be cast naturally in the framework of our abstract contract theory. On the other hand, we also show our contract theory to fulfil the axioms of the meta-theory. In this way, we give further evidence for the utility of the meta-theory, and prepare the ground for combining our instantiation with other, already existing instantiations.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "One of the earliest inspirations for the notion of software contracts came from the works of Floyd [10] and Hoare [15] . One outcome of this was Hoare logic, which is a way of assigning meaning to sequential programs axiomatically, through so-called Hoare triples. A Hoare triple {P }S{Q} consists of two assertions P and Q over the program variables, called the pre-condition and post-condition, respectively, and a program S. The triple states that if the precondition P holds prior to executing S, then, if execution of S terminates, the post-condition Q will hold upon termination. With the help of additional, socalled logical variables, one can specify, with a Hoare triple, the desired relationship between the final values of certain variables (such as the return value of a procedure) and the initial values of certain other variables (such as the formal parameters of the procedure).",
            "cite_spans": [
                {
                    "start": 114,
                    "end": 118,
                    "text": "[15]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "This style of specifying contracts has been advocated by Meyer [18], together with the design methodology Design-by-Contract. A central characteristic of this methodology is that it is well-suited for independent implementation and verification, where software components are developed independently from each other, based solely on the contracts, and without any knowledge of the implementation details of the other components.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Contract Theories. Since then, many other contract theories have emerged, such as Rely/Guarantee reasoning [16, 22] and a number of Assume/Guarantee contract theories [4, 6] . A contract theory typically formalises the notion of contract, and develops a number of operations on contracts that support typical design steps. This in turn has lead to a few developments of contract meta-theories (e.g. [5,2,8]), which aim at unifying these, in many cases incompatible, contract theories. The most comprehensive, and well-known, of these, is presented in Benveniste et al. [5], and is concerned specifically with the design of cyber-physical systems. Here, all properties are derived from a most abstract notion of a contract. The meta-theory focuses on the notion of contract refinement, and the operations of contract conjunction and composition. The intention behind refinement and composition is to support a top-down design flow, where contracts are decomposed iteratively into sub-contracts; the task is then to show that the composition of the sub-contracts refines the original contract. These operations are meant to enable independent development and reuse of components. In addition, the operation of conjunction is intended to allow the superimposition of contracts over the same component, when they concern different aspects of its behaviour. This also enables component reuse, by allowing contracts to reveal only the behaviour relevant to the different use cases.",
            "cite_spans": [
                {
                    "start": 107,
                    "end": 111,
                    "text": "[16,",
                    "ref_id": "BIBREF17"
                },
                {
                    "start": 112,
                    "end": 115,
                    "text": "22]",
                    "ref_id": "BIBREF23"
                },
                {
                    "start": 167,
                    "end": 170,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 171,
                    "end": 173,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Abstract"
        },
        {
            "text": "Motivation and Contribution. The meta-theory of Benveniste et al. focuses on the design of embedded and cyber-physical systems. However, there exists a noticeable gap between this meta-theory and the way contracts are used when developing general software following Meyer's design-by-contract methodology. At the core of this gap appears to be the notion of procedure 1 . While the proce-",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Abstract"
        }
    ],
    "body_text": [
        {
            "text": "Contracts. Loosely speaking, a contract for a software or system component is a means of specifying that the component obliges itself to guarantee a certain behaviour or result, provided that the user (or client) of the component obliges itself to fulfil certain constraints on how it interacts with the component. dure is a central unit of composition in software development, the meta-theory does not suggest an obvious way of treating procedures as components. This situation is not fully satisfactory, since the software components of most embedded systems are implemented with the help of procedures (a typical C-module, for instance, would consist of a main function and a number of helper functions), and their development should ideally follow the same design flow as that of the embedded system as a whole.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "In this paper we provide a first step towards a contract theory that takes procedures as the basic building block, and at the same time respects the axioms of the meta-theory. Our contract theory is abstract, so that it can be instantiated to any procedural language, and similarly to the meta-theory, is presented at the semantics level only. Then, in the context of a simplistic imperative programming language with procedures and its denotational semantics, we show that the specification of contracts of procedures in Hoare logic, and their procedure-modular verification, can be cast in the framework of our abstract contract theory. We also show that our contract theory is an instance of the meta-theory of Benveniste et al. With this we expect to contribute to the bridging of the gap mentioned above, and to give a formal justification of the design methodology supported by the meta-theory, when applied to the software components of embedded systems. Several existing contract theories have already been shown to instantiate the meta-theory. In providing a contract theory for procedural programs that also instantiates it, we increase the value of the metatheory by providing further evidence for its universality. In addition, we prepare the theoretical ground for combining our instantiation with other instantiations, which may target components not to be implemented in software.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Our theoretical development should be seen as a proof-of-concept. In future work it will need to be extended to cover more programming language features, such as object orientation, multi-threading, and exceptions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Related Work. Software contracts and operations on contracts have long been an area of intensive research, as evidenced, e.g., by [1] . We briefly mention some works related to our theory, in addition to the already mentioned ones.",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 133,
                    "text": "[1]",
                    "ref_id": "BIBREF0"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Reasoning from multiple Hoare triples is studied in [21] , in the context of unavailable source code, where new properties cannot be derived by re-verification. In particular, it is found that two Hoare-style rules, the standard rule of consequence and a generalised normalisation rule, are sufficient to infer, from a set of existing contracts for a procedure, any contract that is semantically entailed.",
            "cite_spans": [
                {
                    "start": 52,
                    "end": 56,
                    "text": "[21]",
                    "ref_id": "BIBREF22"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Often-changing source code is a problem for contract-based reasoning and contract reuse. In [13] , abstract method calls are introduced to alleviate this problem. Fully abstract contracts are then introduced in [7] , allowing reasoning about software to be decoupled from contract applicability checks, in a way that not all verification effort is invalidated by changes in a specification.",
            "cite_spans": [
                {
                    "start": 92,
                    "end": 96,
                    "text": "[13]",
                    "ref_id": "BIBREF14"
                },
                {
                    "start": 211,
                    "end": 214,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "The relation between behavioural specifications and assume/guarantee-style contracts for modal transition systems is studied in [2] , which shows how to build a contract framework from any specification theory supporting composition and refinement. This work is built on in [9] , where a formal contract framework based on temporal logic is presented, allowing verification of correctness of contract refinement relative to a specific decomposition.",
            "cite_spans": [
                {
                    "start": 128,
                    "end": 131,
                    "text": "[2]",
                    "ref_id": "BIBREF1"
                },
                {
                    "start": 274,
                    "end": 277,
                    "text": "[9]",
                    "ref_id": "BIBREF8"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "A survey of behavioural specification languages [14] found that existing languages are well-suited for expressing properties of software components, but it is a challenge to express how components interact, making it difficult to reason about system and architectural level properties from detailed design specifications. This provides additional evidence for the gap between contracts used in software verification and contracts as used in system design.",
            "cite_spans": [
                {
                    "start": 48,
                    "end": 52,
                    "text": "[14]",
                    "ref_id": "BIBREF15"
                }
            ],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "Structure. The paper is organised as follows. Section 2 recalls the concept of contract based design and the contract meta-theory considered in the present paper. In Section 3 we present a denotational semantics for programs with procedures, including a semantics for contracts for use in procedure-modular verification. Next, Section 4 presents our abstract contract theory for sequential programs with procedures. Then, we show in Section 5 that our contract theory fulfils the axioms of the meta-theory, while in Section 6 we show how the specification of contracts of procedures in Hoare logic and their procedure-modular verification can be cast in the framework of our abstract contract theory. We conclude with Section 7.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Introduction"
        },
        {
            "text": "This section describes the concept of contract based design, and motivates its use in cyber-physical systems development. We then recall the contract meta-theory by Benveniste et al. [5] .",
            "cite_spans": [
                {
                    "start": 183,
                    "end": 186,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Contract Based Design"
        },
        {
            "text": "Contract based design is an approach to systems design, where the system is developed in a top-down manner through the use of contracts for components, which are incrementally assembled so that they preserve the desired system-wide properties. Contracts are typically described by a set of assumptions the component makes on its environment, and a set of guarantees on the component's behaviour, given that it operates in an environment adhering to the assumptions [5] .",
            "cite_spans": [
                {
                    "start": 465,
                    "end": 468,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Present-day cyber-physical systems, such as those found in the automotive, avionics and other industries, are extremely complex. Products assembled by Original Equipment Manufacturers (OEMs) often consist of components from a number of different suppliers, all using their own specialised design processes, system architectures, development platforms, and tools. This is also true inside the OEMs, where there are different teams with different viewpoints of the system, and their own design processes and tools. In addition, the system itself has several different aspects that need to be managed, such as the architecture, safety and security requirements, functional behaviour, and so on. Thus, a rigorous design framework is called for that can solve these design-chain management issues.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Contract based design addresses these challenges through the principles, at the specification level, of refinement and abstraction, which are processes for managing the design flow between different layers of abstraction, and composition and decomposition, which manage the flow at the same level of abstraction. Generally, when designing a system, at the top level of abstraction there will be an overall system specification (or contract). This top-level contract is then refined, to provide a more concrete contract for the system, and decomposed, in order to obtain contracts for the sub-systems, and to separate the different viewpoints of the system. A system design typically iterates the decompositionand-refinement process, resulting in several layers of abstraction, until contracts are obtained that can be directly implemented, or for which implementations already exist. An important requirement on this methodology of hierarchical decomposition and refinement of contracts is that it must guarantee that when the low-level components implement their concrete contracts, and are combined to form the overall system, then the top-level, abstract, contract shall hold.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Furthermore, a contract framework in particular needs to support independent development and component reuse. That is, specifications for components, and their operations, must allow for components and specifications to be independently designed and implemented, and to be used in different parts of the system, each with their own assumptions on how the other components, the environment, behave. This is achieved through the principle operations on contracts: refinement, composition, and conjunction.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Refinement allows one to extract a contract at the appropriate level of abstraction. A desired property of refinement is that components which have been designed with reference to the more abstract (i.e., weaker) contract do not need to be re-designed after the refinement step. That is, in the early stages of development an OEM may have provided a weak contract for some subsystem to an external supplier, which implemented a component relying on this contract. As development of the system progresses, and the contract is refined, the component supplied externally should still operate according to its guarantees without needing to be changed, when instead assuming the new, refined, contract.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Composition enables one to combine contracts of different components into a contract for the larger subsystem obtained when combining the components. Again, a desirable property is that other components relying on one or more of the individual contracts, can, after composition of the contracts, assume the new contract and still perform its guarantees, without being re-designed, thus ensuring that subsystems can be independently implemented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "Finally, contract conjunction is another way of combining contracts, but now for the different viewpoints of a single component. This allows one to separate a contract into several different, finer contracts for the same component, revealing just enough information for each particular system that depends on it, so that it can be reused in different parts of the system, or in entirely different systems.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract Based Design of Cyber-Physical Systems"
        },
        {
            "text": "We consider the meta-theory described in [5] . The stated purpose of the metatheory has been to distil the notion of a contract to its essence, so that it can be used in system design methodologies without ambiguities. In particular, the meta-theory has been developed to give support for design-chain management, and to allow component reuse and independent development. It has been shown that a number of concrete contract theories instantiate it, including assume/guarantee-contracts, synchronous Moore interfaces, and interface theories. To our knowledge, this is the only meta-theory of its purpose and scope.",
            "cite_spans": [
                {
                    "start": 41,
                    "end": 44,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "A Contract Meta-Theory"
        },
        {
            "text": "We now present the formal definitions of the concepts defined in the metatheory, and the properties that they entail. The meta-theory is defined only in terms of semantics, and it is up to particular concrete instantiations to provide a syntax.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Contract Meta-Theory"
        },
        {
            "text": "Components. The most basic concept in the meta-theory is that of a component, which represents any concrete part of the system. Thus, we have an abstract component universe M with components m \u2208 M. Over pairs of components, we have a composition operation \u00d7. This operation is partially defined, and two components m 1 and m 2 are called composable when m 1 \u00d7 m 2 is defined. In such cases, we call m 1 an environment for m 2 , and vice versa. In addition, component composition must be both commutative and associative, in order to ensure that different components can be combined in any order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Contract Meta-Theory"
        },
        {
            "text": "Typically, components are open, in the sense that they contain functionality provided by other components, i.e., their environment. The environment in which a component is to be placed is often unknown at development time, and although a component cannot restrict it, it is designed for a certain context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "A Contract Meta-Theory"
        },
        {
            "text": "In the meta-theory, the notion of contract is defined in terms of sets of components. The contract universe C def = 2 M \u00d7 2 M consists of contracts C = (E, M ), where E and M are the sets of environments and implementations of C, respectively. Importantly, each pair (m 1 , m 2 ) \u2208 E \u00d7M must be composable. This definition is intentionally abstract. The intuition is that contracts separate the responsibilities of a component from the expectations on its environment. Moreover, contracts are best seen as weak specifications of components: they should expose just enough information to be adequate for their purpose.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contracts."
        },
        {
            "text": "For a component m and a contract C = (E, M ), we shall sometimes write m |= E C for m \u2208 E, and m |= M C for m \u2208 M . A contract C is said to be consistent if it has at least one implementation, and compatible if it has at least one environment.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contracts."
        },
        {
            "text": "As an axiom of the meta-theory, it is required that the greatest lower bound with respect to refinement exists, for all subsets of C. Table 1 summarises the important properties of refinement and the other operations on contracts that a concrete Refinement. When C1 C2, every implementation of C1 is also an implementation of C2.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 134,
                    "end": 141,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "2 Shared refinement. Any contract refining C1 \u2227 C2 also refines C1 and C2. Any implementation of C1 \u2227 C2 is a shared implementation of C1 and C2. Any environment for C1 and C2 is an environment for C1 \u2227 C2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "3 Independent implementability. Compatible contracts can be independently implemented.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "4",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "Independent refinement. For all contracts Ci and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "Commutativity, sub-associativity. For any finite sets of contracts Ci, i = 1, . . . , n, C1 \u2297 C2 = C2 \u2297 C1 and 1\u2264i\u2264n Ci ( 1\u2264i<n Ci) \u2297 Cn holds.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "6",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "Sub-distributivity. The following holds, if all contract compositions in the formula are well defined:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "contract theory needs to possess in order to be considered an instance of the meta-theory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "Contract conjunction. The conjunction of two contracts C 1 and C 2 , denoted",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "; however, this cannot be taken as the definition since not every such pair necessarily constitutes a contract.) Then, we have the three desirable properties of conjunction listed in Table 1 , which together are referred to as shared refinement.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 183,
                    "end": 190,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "Contract composition. The composition of two contracts C 1 = (E 1 , M 1 ) and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": ", is defined when every two components m 1 \u2208 M 1 and m 2 \u2208 M 2 are composable, and must then be the least contract, w.r.t. the refinement order, satisfying the following conditions:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "If all of the above is satisfied, then properties 3-6 of Table 1 hold. The intention is that composing two components implementing C 1 and C 2 should yield an implementation of C 1 \u2297 C 2 , and composing an environment of C 1 \u2297 C 2 with an implementation of C 1 should result in a valid environment for C 2 , and vice versa. This is important in order to enable independent development.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 57,
                    "end": 64,
                    "text": "Table 1",
                    "ref_id": "TABREF0"
                }
            ],
            "section": "Contract refinement. For two contracts"
        },
        {
            "text": "In this section we summarise the background needed to understand the formal developments later in the paper. First, we recall the standard denotational semantics of programs with procedures on a typical toy programming language.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Denotational Semantics of Programs and Contracts"
        },
        {
            "text": "Next, we summarise Hoare logic and contracts, and provide a semantic justification of procedure-modular verification, also based on denotational semantics.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Denotational Semantics of Programs and Contracts"
        },
        {
            "text": "This section sketches the standard presentation of denotational semantics for procedural languages, as presented in textbooks such as [23, 19] . This semantics is the inspiration for the definition of components in our abstract contract theory in Section 4.1. We start with a simplistic programming language not involving procedures, and add procedures later to the language.",
            "cite_spans": [
                {
                    "start": 134,
                    "end": 138,
                    "text": "[23,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 139,
                    "end": 142,
                    "text": "19]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "The following toy sequential programming language is typically used to present the denotational semantics of imperative languages:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "where S ranges over statements, a over arithmetic expressions, and b over Boolean expressions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "To define the denotational semantics of the language, we define the set State of program states. A state s \u2208 State is a mapping from the program variables to, for simplicity, the set of integers.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "The ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "For the treatment of the remaining statements of the language, the reader is referred to [23, 19] .",
            "cite_spans": [
                {
                    "start": 89,
                    "end": 93,
                    "text": "[23,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 94,
                    "end": 97,
                    "text": "19]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "The definition of denotation captures through its type (as a partial function) that the execution of statements is deterministic. For non-deterministic programs, the type of denotations is relaxed to",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "captures that there is an execution of S starting in s that terminates in s . For technical reasons that will become clear below, we shall use this latter denotation type in our treatment.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Note that we could alternatively have chosen State + as the denotational domain, and most results would still hold in the context of finite-trace semantics. However, we chose to develop the theory with a focus on Hoare-logic and deductive verification. In fact, the domain State \u00d7 State can be seen as a special case of finite traces. In future work, we will also investigate concrete contract languages based on this semantics, and extend the theory for that context.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Procedures and Procedure Calls. To extend the language and its denotational semantics with procedures and procedure calls, we follow again the approach of [23] , but adapt it to an \"open\" setting, where some called procedures might not be declared. We consider programs in the context of a finite set P of procedure names (of some larger, \"closed\" program), and a set of procedure declarations of the form proc p is S p , where p \u2208 P. Further, we extend the toy programming language with the statement call p. Listing 1.1. An even-odd toy program. proc even i s i f n = 0 then r := 1 e l s e ( n := n \u2212 1 ; c a l l odd ) ; proc odd i s i f n = 0 then r := 0 e l s e ( n := n \u2212 1 ; c a l l even )",
            "cite_spans": [
                {
                    "start": 155,
                    "end": 159,
                    "text": "[23]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "As an example, Listing 1.1 shows a (closed) program in the toy language, implementing two mutually recursive procedures. The procedures check whether the value of the global variable n is even or odd, respectively, and assign the corresponding truth value to the variable r.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Due to the (potential) recursion in the procedure declarations, the denotation of call p, and thus of the whole language, cannot be defined by structural induction as directly as before. We therefore define, for any set P \u2286 P of procedure names, the set Env P = P \u2192 2 State\u00d7State of procedure environments, each environment \u03c1 \u2208 Env P thus providing a denotation for each procedure in P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Let Env def = P \u2286P Env P be the set of all procedure environments. We define a partial order relation on procedure environments, as follows. For any two procedure environments \u03c1 \u2208 Env P and \u03c1 \u2208 Env P , \u03c1 \u03c1 if and only if P \u2286 P and \u2200p \u2208 P. \u03c1(p) \u2286 \u03c1 (p).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Recall that a complete lattice is a partial order, every set of elements of which has a greatest lower bound (glb) within the domain of the lattice (see, e.g., [23] ). It is easy to show that for any P \u2286 P, (Env P , ) is a complete lattice, since a greatest lower bound will exist within Env P . Then, the least upper bound (lub) \u03c1 1 \u03c1 2 of any two function environments \u03c1 1 \u2208 Env P1 and \u03c1 2 \u2208 Env P2 also exists, and is the environment \u03c1 \u2208 Env P1\u222aP2 such that \u2200p \u2208 P 1 \u222aP 2 . \u03c1(p) = \u03c1 1 (p)\u222a\u03c1 2 (p).",
            "cite_spans": [
                {
                    "start": 160,
                    "end": 164,
                    "text": "[23]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "We will sometimes need a procedure environment that maps every procedure in P to State \u00d7 State, and we shall denote this environment by \u03c1 P .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Next, for sets of procedures, we shall need the notion of interface, which is a pair (P \u2212 , P + ) of disjoint sets of procedure names, where P + \u2286 P is a set of provided (or declared) procedures, and P \u2212 \u2286 P a set of required (or called, but not declared) ones.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Then, we (re)define the notion of denotation of statements S in the context of a given interface (P \u2212 , P + ) and environments \u03c1 \u2212 \u2208 Env P \u2212 and \u03c1 + \u2208 Env P + , and denote it by",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Intuitively, the denotation of a call to a procedure should be equal to the denotation of the body of the latter. We therefore introduce, given an environment \u03c1 \u2212 \u2208 Env P \u2212 , the function \u03be : Env",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "for any \u03c1 + \u2208 Env P + and p \u2208 P + , and consider its fixed points. By the Knaster-Tarski Fixed-Point Theorem (as stated, e.g., in [23] ), since (Env P + , ) is a complete lattice and \u03be is monotonic, \u03be has a least fixed-point \u03c1 + 0 .",
            "cite_spans": [
                {
                    "start": 130,
                    "end": 134,
                    "text": "[23]",
                    "ref_id": "BIBREF24"
                }
            ],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "Finally, we define the notion of standard denotation of statement S in the context of a given interface (P \u2212 , P + ) and environment \u03c1 \u2212 \u2208 Env P \u2212 , denoted ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "The Denotational Semantics of Programs with Procedures"
        },
        {
            "text": "In this section we summarise the denotational semantics of Hoare logic and the semantic justification of procedure-modular verification, as developed by the second author in [12] . These formalisations serve as the starting point for the definition of contracts in our contract theory developed in Section 4.2.",
            "cite_spans": [
                {
                    "start": 174,
                    "end": 178,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "Hoare Logic. The basic judgement of Hoare logic [15] is the Hoare triple, written {P }S{Q}, where P and Q are assertions over the program state, and S is a program statement. The Hoare triple signifies that if the statement S is executed from a state that satisfies P (called the pre-condition), and if this execution terminates, then the final state of the execution will satisfy Q (called the postcondition). Additionally, so-called logical variables can be used within a Hoare triple, to specify the desired relationship between the values of variables after execution and the values of variables before execution. The values of the program variables are defined by the notion of state; to give a meaning to the logical variables we shall use interpretations I. We shall write s |= I P to signify that the assertion P is true w.r.t. state s and interpretation I. The formal validity of a Hoare triple is denoted by |= par {P }S{Q}, where the subscript signifies that validity is in terms of partial correctness, where termination of the execution of S is not required.",
            "cite_spans": [
                {
                    "start": 48,
                    "end": 52,
                    "text": "[15]",
                    "ref_id": "BIBREF16"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "An example of a Hoare triple, stating the desired behaviour of procedure odd from Listing 1.1, is shown below, where we use the logical variable n 0 to capture to the value of n prior to execution of odd :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "Procedure even is specified analogously.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "Hoare logic comes with a proof calculus for reasoning in terms of Hoare triples, consisting of proof rules for the different types of statements of the programming language. An example is the rule for sequential composition:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "Composition which essentially states that if executing S 1 from any state satisfying P terminates (if at all) in some state satisfying R, and executing S 2 from any state satisfying R terminates (if at all) in some state satisfying Q, then it is the case that executing the composition S 1 ; S 2 from any state satisfying P terminates (if at all) in some state satisfying Q. The proof system is sound and relatively complete w.r.t. the denotational semantics of the programming language (see, e.g., [23, 19] ).",
            "cite_spans": [
                {
                    "start": 499,
                    "end": 503,
                    "text": "[23,",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 504,
                    "end": 507,
                    "text": "19]",
                    "ref_id": "BIBREF20"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "Hoare Logic Contracts. One can view a Hoare triple {P }S{Q} as a contract C = (P, Q) imposed on the program S. In many contexts it is meaningful to separate the contract from the program; for instance, if the program is yet to be implemented. In our earlier work [12] , we gave such contracts a denotational semantics as follows:",
            "cite_spans": [
                {
                    "start": 263,
                    "end": 267,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "The rationale behind this definition is the following desirable property: a program meets a contract whenever its denotation is subsumed by the denotation of the contract, i. The Denotational Semantics of Programs with Procedure Contracts. Let S be a program with procedures, and let every declared procedure p \u2208 P be equipped with a procedure contract C p . Procedure-modular verification refers to techniques that verify every procedure in isolation. The key to this is to handle procedure calls by using the contract of the called procedure rather than its body (i.e., by contracting rather than by inlining [7] ). In [12] , a semantic justification of this is given by means of a contract-relative denotational semantics of statements. The intuition behind this semantics is that procedure calls are given a meaning through the denotation of the contract of the called procedure, rather than through the denotation of its body.",
            "cite_spans": [
                {
                    "start": 611,
                    "end": 614,
                    "text": "[7]",
                    "ref_id": "BIBREF6"
                },
                {
                    "start": 621,
                    "end": 625,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "The contract-relative denotational semantics of a statement S, denoted [[S]] cr , is defined with the help of the contract environment \u03c1 c that is induced by the procedure contracts, i.e., \u03c1 c (p) ]. This is exactly the correctness notion that is the target of procedure-modular verification. As shown in [12] , this notion is sound w.r.t. the original notion S |= par C, in the sense that S |= cr par C entails S |= par C. In other words, verifying a program procedure-modularly establishes that the program is correct w.r.t. its contract in the standard sense.",
            "cite_spans": [
                {
                    "start": 305,
                    "end": 309,
                    "text": "[12]",
                    "ref_id": "BIBREF13"
                }
            ],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "For example, the contract-relative semantics of S even is such that (s, s ) \u2208 if s(n) is even and s (r) = 0 if s(n) is odd. The contract-relative semantics of S odd is analogous. Then, it is easy to check that both S even |= cr par C even and S odd |= cr par C odd hold.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Hoare Logic and Contracts"
        },
        {
            "text": "This section presents an abstract contract theory for programs with procedures. The theory builds on the basic notion of denotation as a binary relation over states. As we will show later, it is both an abstraction of the denotational semantic view on programs with procedures and procedure contracts presented in Sections 3.1 and 3.2, and an instantiation of the meta-theory described in Section 2.2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "An Abstract Contract Theory"
        },
        {
            "text": "In the context of a concrete programming language, we view a component as a module, consisting of a collection of procedures that are provided by the module. The module may call required procedures that are external to the module. The way the provided procedures transform the program state upon a call depends on how the required procedures transform the state. We take this observation as the basis of our abstract setting, in which state transformers are modelled as denotations (i.e., as binary relations over states). A component will thus be simply a mapping from denotations of the required procedures to denotations of the provided ones, both captured through the notion of procedure environments. The contract theory is abstract, in that it is not defined for a particular programming language, and may be instantiated with any procedural language. As with the meta-theory, the abstract contract theory is also defined only on the semantic level.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Components"
        },
        {
            "text": "Recall the notions and notation from Section 3.1. A component interface I = (P \u2212 , P + ) is a pair of disjoint, finite sets of procedure names, of the required and the provided ones, respectively.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Components"
        },
        {
            "text": "Let M denote the universe of all components over P.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Component). A component m with interface"
        },
        {
            "text": "We assume that any system is built up from a set of base components, the simplest components from which more complex components are then obtained by composition. The base components must be monotonic functions over the lattice defined in Section 3.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Component). A component m with interface"
        },
        {
            "text": "When P \u2212 m = \u2205, we shall identify m with an element of Env P + m . In other words, when a component is closed, i.e., is not dependent on any external procedures, the provided environment is constant.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Component). A component m with interface"
        },
        {
            "text": "Definition 2 (Component composability). Two components m 1 and m 2 are composable iff P + m1 \u2229 P + m2 = \u2205.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Component). A component m with interface"
        },
        {
            "text": "When defining the composition of two components, particular care is required in the treatment of procedure names that are provided by one of the components while required by the other. Let \u03bcx. f (x) denote the least fixed-point of a function f , when it exists.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 1 (Component). A component m with interface"
        },
        {
            "text": ", their composition is defined as a mapping m 1 \u00d7 m 2 : Env P \u2212 m 1 \u00d7m 2 \u2192 Env P + m 1 \u00d7m 2 such that:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Component composition). Given two composable components"
        },
        {
            "text": "is defined, in the context of a given",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Component composition). Given two composable components"
        },
        {
            "text": "be defined symmetrically. We then define:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Component composition). Given two composable components"
        },
        {
            "text": "In the above definition, \u03c7 + m1\u00d7m2 represents the denotations of the procedure bodies of the procedures provided by the two composed components, given denotations of procedure calls to the same procedures. The choice of least fixed-point will be crucial for the proof of Theorem 2(i) in Section 4.2 below.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Component composition). Given two composable components"
        },
        {
            "text": "The definition is well-defined, in the sense that the stated least fixed-points exist, and the resulting components are monotonic functions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 3 (Component composition). Given two composable components"
        },
        {
            "text": "The existence of a least fixed-point follows from the Knaster-Tarski Fixed-Point Theorem, as stated, e.g., in [23] . It can then be shown, by structural induction, that composition is well-defined. For lack of space, the proofs of all theorems, some of which are conceptually not very involved but rather verbose, are omitted here. The full proofs can be found in the accompanying technical report [17] .",
            "cite_spans": [
                {
                    "start": 110,
                    "end": 114,
                    "text": "[23]",
                    "ref_id": "BIBREF24"
                },
                {
                    "start": 398,
                    "end": 402,
                    "text": "[17]",
                    "ref_id": "BIBREF18"
                }
            ],
            "ref_spans": [],
            "section": "Theorem 1. Component composition is well-defined."
        },
        {
            "text": "We now define the notion of denotational contracts c in the style of assume/guarantee contracts [4, 6] . Contracts shall also be given interfaces.",
            "cite_spans": [
                {
                    "start": 96,
                    "end": 99,
                    "text": "[4,",
                    "ref_id": "BIBREF3"
                },
                {
                    "start": 100,
                    "end": 102,
                    "text": "6]",
                    "ref_id": "BIBREF5"
                }
            ],
            "ref_spans": [],
            "section": "Denotational Contracts"
        },
        {
            "text": "and \u03c1 + c \u2208 Env P + c . The intended interpretation of the environment pair is as follows: assuming that the denotation of every called procedure p \u2208 P \u2212 c is subsumed by \u03c1 \u2212 c (p), then it is guaranteed that the denotation of every provided procedure p \u2208 P + c is subsumed by \u03c1 + c (p ).",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 4 (Denotational contract). A denotational contract c with in-"
        },
        {
            "text": "The reason for not requiring the interfaces to be equal is that we aim at a subset relation between components implementing a contract and those implementing a refinement of said contract, in the meta-theory instantiation. ",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 5 (Contract implementation). A component m with interface"
        },
        {
            "text": "Intuitively, an environment of a contract c is then a component such that when it is composed with an implementation of c, the composition will operate satisfactorily with respect to the guarantee of the contract. We will now define the refinement relation, and the conjunction and composition operations, on contracts. The refinement relation reflects the intention that if a contract c refines another contract c , then any component implementing c should also implement c . This definition is consistent with the intention that any contract that refines c 1 \u2227 c 2 should also refine c 1 and c 2 individually. The interface of c 1 \u2227 c 2 is then",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 5 (Contract implementation). A component m with interface"
        },
        {
            "text": ". Note that while this is the interface in general, conjunction of contracts is typically used to merge different viewpoints of the same component, and in that case I c1 = I c2 = I c1\u2227c2 .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Contract conjunction). The conjunction of two contracts"
        },
        {
            "text": "Definition 9 (Contract composability). Two contracts c 1 = (\u03c1 \u2212 c1 , \u03c1 + c1 ) and c 2 = (\u03c1 \u2212 c2 , \u03c1 + c2 ) with interfaces I c1 = (P \u2212 c1 , P + c1 ) and I c2 = (P \u2212 c2 , P + c2 ) are composable if:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Contract conjunction). The conjunction of two contracts"
        },
        {
            "text": "The conditions for composability ensure that the mutual guarantees of the two contracts meet each other's assumptions.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Contract conjunction). The conjunction of two contracts"
        },
        {
            "text": "Definition 10 (Contract composition). The composition of two composable contracts c 1 = (\u03c1 \u2212 c1 , \u03c1 + c1 ) and c 2 = (\u03c1 \u2212 c2 , \u03c1 + c2 ), with interfaces I c1 = (P \u2212 c1 , P + c1 ) and",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Contract conjunction). The conjunction of two contracts"
        },
        {
            "text": "For any composable contracts c 1 and c 2 , and any implementations m 1 |= c 1 and m 2 |= c 2 , m 1 and m 2 are composable, and c 1 \u2297 c 2 is the least contract (w.r.t. refinement order) for which the following properties hold:",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Definition 8 (Contract conjunction). The conjunction of two contracts"
        },
        {
            "text": "In this section we show that the abstract contract theory presented in Section 4 instantiates the meta-theory described in Section 2.2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "In our instantiation of the meta-theory, we consider as the abstract component universe M the same universe of components M as defined in Section 4.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "To distinguish the contracts of the meta-theory from those of the abstract theory, we shall always denote the former by C and the latter by c. Recall that a contract C is a pair (E, M ), where E, M \u2286 M. The formal connection between the two notions is established with the following definition. Since contract implementation requires that the implementing component's provided functions are a subset of the contract's provided functions, every component m such that P + m \u2229 P + c = \u2205 is composable with every component in M c . The definitions of implementation, refinement and conjunction of denotational contracts make this straightforward definition of induced contracts possible, so that it directly results in refinement as set membership and conjunction as lub w.r.t. the refinement order.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "Theorem 3. The contract theory of Section 4 instantiates the meta-theory of Benveniste et al. [5] , in the sense that composition of components is associative and commutative, and for any two contracts c 1 and c 2 :",
            "cite_spans": [
                {
                    "start": 94,
                    "end": 97,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                }
            ],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "(i) c 1 c 2 iff C c1 refines C c2 according to the definition of the meta-theory, (ii) C c1\u2227c2 is the conjunction of C c1 and C c2 as defined in the meta-theory, and (iii) C c1\u2297c2 is the composition of C c1 and C c2 as defined in the meta-theory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "The proof is straightforward, since many definitions of the contract theory are deliberately similar to their counterparts in the meta-theory.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "Let us now return to our example from Section 3. When applying Contract Based Design, contracts at the more abstract level will be decomposed into contracts at the more concrete level. So, for our example, we might have at the top level a contract c = (\u03c1 \u2212 c , \u03c1 + c ) with interface (\u2205, {even, odd}) , where \u03c1 \u2212 c = \u2205, and where \u03c1 + c \u2208 Env P + c maps even to the set of pairs (s, s ) such that whenever s(n) is non-negative and even, then s (r) = 1, and when s(n) is non-negative and odd, then s (r) = 0, and maps odd in a dual manner. This contract could then be decomposed into two contracts c even and c odd , so that \u03c1 + ceven (even) def = \u03c1 + c (even) and \u03c1 \u2212 ceven (odd ) def = \u03c1 + c (odd ), and c odd is analogous. Then, we would have c even \u2297 c odd c, and for any two components m even and m odd such that m even |= c even and m odd |= c odd , it would hold that m even \u00d7 m odd |= c.",
            "cite_spans": [],
            "ref_spans": [
                {
                    "start": 284,
                    "end": 300,
                    "text": "(\u2205, {even, odd})",
                    "ref_id": null
                }
            ],
            "section": "Connection to Meta-Theory"
        },
        {
            "text": "In this section we discuss how our abstract contract theory from Section 4 relates to programs with procedures as presented in Section 3.1, and how it relates to Hoare logic and procedure-modular verification as presented in Section 3.2.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "First, we define how to abstract the denotational notion of procedures into components in the abstract theory, based on the function \u03be from Section 3.1.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "Definition 12 (From procedure sets to components). For any set of procedures P + , calling procedures P , we define the component m :",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "As the next result shows, procedure set abstraction and component composition commute. Together with commutativity and associativity of component composition, this means that the initial grouping of procedures into components is irrelevant, and that one can start with abstracting each individual procedure into a component. The result is a direct consequence of Definition 12, Definition 3, and the well-known Beki\u0107's Lemma [3] about simultaneous fixed-points. \u03c1 + = \u03be(\u03c1 + )(even). Similarly \u03c7 + meven \u00d7m odd (\u03c1 + )(odd ) = \u03be(\u03c1 + )(odd ). We therefore have m even \u00d7 m odd = m.",
            "cite_spans": [
                {
                    "start": 425,
                    "end": 428,
                    "text": "[3]",
                    "ref_id": "BIBREF2"
                }
            ],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "We now define how to abstract Hoare logic contracts into denotational contracts, in terms of the contract environment \u03c1 c defined in Section 3.2. In this way, conceptually, denotational contracts become assume/guaranteestyle specifications over Hoare logic procedure contracts: assuming that all (ex-ternal) procedures called by a procedure p transform the state according to their Hoare logic contracts, procedure p obliges itself to do so as well.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "We now show that if a procedure implements a Hoare logic contract, then the abstracted component will implement the abstracted contract, and vice versa. Together with Theorem 4, this result allows the procedure-modular verification of abstract components.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "Theorem 5. For any procedure p with procedure contract C p , abstracted into component m p with contract c p , we have S p |= cr par C p iff m p |= c p .",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "The result follows mainly from Definitions 12 and 13, and the denotational semantics given in Section 3.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "Returning to the example from Sections 3 and 5, we can abstract the procedure set {even} into component m even , with interface ({odd}, {even}), which would be a function Env {odd} \u2192 Env {even} , and \u2200\u03c1 \u2212 \u2208 Env {odd} . m(\u03c1 \u2212 )(even) = [[S even ]] \u03c1 \u2212 . The denotational contracts c even and c odd resulting from the decomposition shown in Section 5, would be exactly the abstraction of the Hoare Logic contracts C even and C odd shown in Section 3.2. They would both be part of the contract environment used in procedure-modular verification, for example when verifying that S even |= cr par C even , which would entail m even |= c even . Thus, by applying standard procedure-modular verification at the source code level, we prove the top-level contract c proposed in Section 5.",
            "cite_spans": [],
            "ref_spans": [],
            "section": "Connection to Programs with Procedures"
        },
        {
            "text": "We presented an abstract contract theory for procedural languages, based on denotational semantics. The theory is shown to be an instance of the meta-theory of [5] , and at the same time an abstraction of the standard denotational semantics of procedural languages. We believe that our contract theory can be used to support the development of cyber-physical and embedded systems by the design methodology supported by the meta-theory, allowing the individual procedures of the embedded software to be treated as any other system component. The work also strengthens the claims of the meta-theory of distilling the notion of contracts to its essence, by showing that it is applicable also in the context of procedural programs and deductive verification. Finally, this work serves as a preparation for combining our contract theory for procedural programs with other instantiations of the meta-theory. In future work we plan to investigate the utility of our contract theory on real embedded systems taken from the automotive industry, where not all components are procedural programs, or even software (cf. our previous work, e.g., [11] ). We also plan to extend our toy imperative language with additional features, such as procedure parameters and return values. Furthermore, we plan to extend the contract theory to capture program traces by developing a finite-trace semantics, to enable its use in the specification and verification of temporal properties. Lastly, we plan to combine our contract theory with an existing contract theory for hybrid systems [20] .",
            "cite_spans": [
                {
                    "start": 160,
                    "end": 163,
                    "text": "[5]",
                    "ref_id": "BIBREF4"
                },
                {
                    "start": 1133,
                    "end": 1137,
                    "text": "[11]",
                    "ref_id": "BIBREF11"
                },
                {
                    "start": 1562,
                    "end": 1566,
                    "text": "[20]",
                    "ref_id": "BIBREF21"
                }
            ],
            "ref_spans": [],
            "section": "Conclusion"
        }
    ],
    "bib_entries": {
        "BIBREF0": {
            "ref_id": "b0",
            "title": "Composing specifications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Abadi",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Lamport",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "ACM Trans. Program. Lang. Syst",
            "volume": "15",
            "issn": "1",
            "pages": "73--132",
            "other_ids": {
                "DOI": [
                    "10.1145/151646.151649"
                ]
            }
        },
        "BIBREF1": {
            "ref_id": "b1",
            "title": "Moving from specifications to contracts in component-based design",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Bauer",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "David",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Hennicker",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [],
                    "last": "Larsen",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Legay",
                    "suffix": ""
                },
                {
                    "first": "U",
                    "middle": [],
                    "last": "Nyman",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Wasowski",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Fundamental Approaches to Software Engineering",
            "volume": "",
            "issn": "",
            "pages": "43--58",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-28872-2_3"
                ]
            }
        },
        "BIBREF2": {
            "ref_id": "b2",
            "title": "Definable operation in general algebras, and the theory of automata and flowcharts",
            "authors": [
                {
                    "first": "H",
                    "middle": [],
                    "last": "Beki\u0107",
                    "suffix": ""
                }
            ],
            "year": 1984,
            "venue": "Programming Languages and Their Definition -Hans Beki\u0107",
            "volume": "177",
            "issn": "",
            "pages": "30--55",
            "other_ids": {
                "DOI": [
                    "10.1007/BFb0048939"
                ]
            }
        },
        "BIBREF3": {
            "ref_id": "b3",
            "title": "Multiple viewpoint contract-based specification and design",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Benveniste",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Caillaud",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ferrari",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Mangeruca",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Passerone",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sofronis",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "Formal Methods for Components and Objects",
            "volume": "5382",
            "issn": "",
            "pages": "200--225",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-540-92188-2_9"
                ]
            }
        },
        "BIBREF4": {
            "ref_id": "b4",
            "title": "Contracts for System Design",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Benveniste",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Caillaud",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Nickovic",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Passerone",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [
                        "B"
                    ],
                    "last": "Raclet",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "Reinkemeier",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Sangiovanni-Vincentelli",
                    "suffix": ""
                },
                {
                    "first": "W",
                    "middle": [],
                    "last": "Damm",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [
                        "A"
                    ],
                    "last": "Henzinger",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "G"
                    ],
                    "last": "Larsen",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "12",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1561/1000000053"
                ]
            }
        },
        "BIBREF5": {
            "ref_id": "b5",
            "title": "A contract-based formalism for the specification of heterogeneous systems",
            "authors": [
                {
                    "first": "L",
                    "middle": [],
                    "last": "Benvenuti",
                    "suffix": ""
                },
                {
                    "first": "A",
                    "middle": [],
                    "last": "Ferrari",
                    "suffix": ""
                },
                {
                    "first": "L",
                    "middle": [],
                    "last": "Mangeruca",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Mazzi",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Passerone",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Sofronis",
                    "suffix": ""
                }
            ],
            "year": 2008,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "142--147",
            "other_ids": {
                "DOI": [
                    "10.1109/FDL.2008.4641436"
                ]
            }
        },
        "BIBREF6": {
            "ref_id": "b6",
            "title": "Fully abstract operation contracts",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bubel",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "H\u00e4hnle",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Pelevina",
                    "suffix": ""
                }
            ],
            "year": 2014,
            "venue": "Leveraging Applications of Formal Methods, Verification and Validation. Specialized Techniques and Applications",
            "volume": "",
            "issn": "",
            "pages": "120--134",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-662-45231-8_9"
                ]
            }
        },
        "BIBREF7": {
            "ref_id": "b7",
            "title": "A compositional specification theory for component behaviours",
            "authors": [
                {
                    "first": "T",
                    "middle": [],
                    "last": "Chen",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Chilton",
                    "suffix": ""
                },
                {
                    "first": "B",
                    "middle": [],
                    "last": "Jonsson",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Kwiatkowska",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "Programming Languages and Systems",
            "volume": "",
            "issn": "",
            "pages": "148--168",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-28869-2_8"
                ]
            }
        },
        "BIBREF8": {
            "ref_id": "b8",
            "title": "Contracts-refinement proof system for componentbased embedded systems",
            "authors": [
                {
                    "first": "A",
                    "middle": [],
                    "last": "Cimatti",
                    "suffix": ""
                },
                {
                    "first": "S",
                    "middle": [],
                    "last": "Tonetta",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Science of Computer Programming",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF10": {
            "ref_id": "b10",
            "title": "Assigning meanings to programs",
            "authors": [
                {
                    "first": "R",
                    "middle": [
                        "W"
                    ],
                    "last": "Floyd",
                    "suffix": ""
                }
            ],
            "year": 1967,
            "venue": "Mathematical aspects of computer science",
            "volume": "19",
            "issn": "",
            "pages": "19--32",
            "other_ids": {
                "DOI": [
                    "10.1007/978-94-011-1793-7_4"
                ]
            }
        },
        "BIBREF11": {
            "ref_id": "b11",
            "title": "Deductive functional verification of safety-critical embedded c-code: An experience report",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gurov",
                    "suffix": ""
                },
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lidstr\u00f6m",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nyberg",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Westman",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Proceedings of FMICS-AVoCS",
            "volume": "10471",
            "issn": "",
            "pages": "3--18",
            "other_ids": {}
        },
        "BIBREF13": {
            "ref_id": "b13",
            "title": "A Hoare Logic Contract Theory: An Exercise in Denotational Semantics",
            "authors": [
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gurov",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Westman",
                    "suffix": ""
                }
            ],
            "year": 2018,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "119--127",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-98047-8_8"
                ]
            }
        },
        "BIBREF14": {
            "ref_id": "b14",
            "title": "Reuse in software verification by abstract method calls",
            "authors": [
                {
                    "first": "R",
                    "middle": [],
                    "last": "H\u00e4hnle",
                    "suffix": ""
                },
                {
                    "first": "I",
                    "middle": [],
                    "last": "Schaefer",
                    "suffix": ""
                },
                {
                    "first": "R",
                    "middle": [],
                    "last": "Bubel",
                    "suffix": ""
                }
            ],
            "year": 2013,
            "venue": "Automated Deduction -CADE-24",
            "volume": "7898",
            "issn": "",
            "pages": "300--314",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-642-38574-2_21"
                ]
            }
        },
        "BIBREF15": {
            "ref_id": "b15",
            "title": "Behavioral interface specification languages",
            "authors": [
                {
                    "first": "J",
                    "middle": [],
                    "last": "Hatcliff",
                    "suffix": ""
                },
                {
                    "first": "G",
                    "middle": [
                        "T"
                    ],
                    "last": "Leavens",
                    "suffix": ""
                },
                {
                    "first": "K",
                    "middle": [
                        "R M"
                    ],
                    "last": "Leino",
                    "suffix": ""
                },
                {
                    "first": "P",
                    "middle": [],
                    "last": "M\u00fcller",
                    "suffix": ""
                },
                {
                    "first": "M",
                    "middle": [],
                    "last": "Parkinson",
                    "suffix": ""
                }
            ],
            "year": 2012,
            "venue": "ACM Comput. Surv",
            "volume": "44",
            "issn": "3",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1145/2187671.2187678"
                ]
            }
        },
        "BIBREF16": {
            "ref_id": "b16",
            "title": "An axiomatic basis for computer programming",
            "authors": [
                {
                    "first": "C",
                    "middle": [
                        "A R"
                    ],
                    "last": "Hoare",
                    "suffix": ""
                }
            ],
            "year": 1969,
            "venue": "Commun. ACM",
            "volume": "12",
            "issn": "10",
            "pages": "576--580",
            "other_ids": {
                "DOI": [
                    "10.1145/363235.363259"
                ]
            }
        },
        "BIBREF17": {
            "ref_id": "b17",
            "title": "Specification and design of (parallel) programs",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Jones",
                    "suffix": ""
                }
            ],
            "year": 1983,
            "venue": "Proceedings Of IFIP'83",
            "volume": "83",
            "issn": "",
            "pages": "321--332",
            "other_ids": {}
        },
        "BIBREF18": {
            "ref_id": "b18",
            "title": "An abstract contract theory for programs with procedures (full version)",
            "authors": [
                {
                    "first": "C",
                    "middle": [],
                    "last": "Lidstr\u00f6m",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gurov",
                    "suffix": ""
                }
            ],
            "year": 2021,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF19": {
            "ref_id": "b19",
            "title": "Applying \"design by contract\"",
            "authors": [
                {
                    "first": "B",
                    "middle": [],
                    "last": "Meyer",
                    "suffix": ""
                }
            ],
            "year": 1992,
            "venue": "IEEE Computer",
            "volume": "25",
            "issn": "10",
            "pages": "40--51",
            "other_ids": {
                "DOI": [
                    "10.1109/2.161279"
                ]
            }
        },
        "BIBREF20": {
            "ref_id": "b20",
            "title": "Semantics with Applications: An Appetizer",
            "authors": [
                {
                    "first": "H",
                    "middle": [
                        "R"
                    ],
                    "last": "Nielson",
                    "suffix": ""
                },
                {
                    "first": "F",
                    "middle": [],
                    "last": "Nielson",
                    "suffix": ""
                }
            ],
            "year": 2007,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {
                "DOI": [
                    "10.1007/978-1-84628-692-6"
                ]
            }
        },
        "BIBREF21": {
            "ref_id": "b21",
            "title": "Formally proving compositionality in industrial systems with informal specifications",
            "authors": [
                {
                    "first": "M",
                    "middle": [],
                    "last": "Nyberg",
                    "suffix": ""
                },
                {
                    "first": "J",
                    "middle": [],
                    "last": "Westman",
                    "suffix": ""
                },
                {
                    "first": "D",
                    "middle": [],
                    "last": "Gurov",
                    "suffix": ""
                }
            ],
            "year": 2020,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "348--365",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-030-61467-6_22"
                ]
            }
        },
        "BIBREF22": {
            "ref_id": "b22",
            "title": "Hoare-style reasoning from multiple contracts",
            "authors": [
                {
                    "first": "O",
                    "middle": [],
                    "last": "Owe",
                    "suffix": ""
                },
                {
                    "first": "T",
                    "middle": [],
                    "last": "Ramezanifarkhani",
                    "suffix": ""
                },
                {
                    "first": "E",
                    "middle": [],
                    "last": "Fazeldehkordi",
                    "suffix": ""
                }
            ],
            "year": 2017,
            "venue": "Integrated Formal Methods -13th International Conference",
            "volume": "10510",
            "issn": "",
            "pages": "263--278",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-66845-1_17"
                ]
            }
        },
        "BIBREF23": {
            "ref_id": "b23",
            "title": "On rely-guarantee reasoning",
            "authors": [
                {
                    "first": "S",
                    "middle": [],
                    "last": "Van Staden",
                    "suffix": ""
                }
            ],
            "year": 2015,
            "venue": "Mathematics of Program Construction",
            "volume": "",
            "issn": "",
            "pages": "30--49",
            "other_ids": {
                "DOI": [
                    "10.1007/978-3-319-19797-5_2"
                ]
            }
        },
        "BIBREF24": {
            "ref_id": "b24",
            "title": "The Formal Semantics of Programming Languages: An Introduction",
            "authors": [
                {
                    "first": "G",
                    "middle": [],
                    "last": "Winskel",
                    "suffix": ""
                }
            ],
            "year": 1993,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        },
        "BIBREF26": {
            "ref_id": "b26",
            "title": "), which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license and indicate if changes were made. The images or other third party material in this chapter are included in the chapter's Creative Commons license, unless indicated otherwise in a credit line to the material. If material is not included in the chapter's Creative Commons license and your intended use is not permitted by statutory regulation or exceeds the permitted use",
            "authors": [],
            "year": null,
            "venue": "",
            "volume": "",
            "issn": "",
            "pages": "",
            "other_ids": {}
        }
    },
    "ref_entries": {
        "FIGREF0": {
            "text": "0 is the least fixed-point defined above. For example, for the closed program in Listing 1.1, we have an interface with P + = {even, odd } and P \u2212 = \u2205. Then, (s,s ) \u2208 [[S even ]] \u03c1 + \u03c1 \u2212 if either s(n) = 0 and s = s[r \u2192 1], or else if s(n) > 0 and (s[n \u2192 s(n) \u2212 1], s ) \u2208 \u03c1 + (odd ). The denotation [[S odd ]] \u03c1 + \u03c1 \u2212 is analogous. The resulting least fixed-point \u03c1 + 0 is such that (s, s ) \u2208 [[S even ]] \u03c1 \u2212 ,or equivalently (s, s ) \u2208 [[S even ]] \u03c1 + 0 \u03c1 \u2212 , whenever s(n) \u2265 0, and either s(n) is even and then s (n) = 0 and s (r) = 1, or else s(n) is odd and then s (n) = 0 and s (r) = 0. The standard denotation [[S odd ]] \u03c1 \u2212 of odd is analogous.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF1": {
            "text": "e., S |= par C if and only if [[S]] \u2286 [[C]]. For example, for the contract C odd induced by (1) we have that (s, s ) \u2208 [[C odd ]] if and only if either s(n) < 0, or else s (r) = 0 if s(n) is even and s (r) = 1 if s(n) is odd. The denotation of C even is analogous.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF2": {
            "text": "def = [[C p ]] for all p \u2208 P, as [[S]] cr def = [[S]] \u03c1c . Notice that this definition does not involve solving any recursive equations (i.e., finding fixed points), and gives rise to a contract-relative notion of when a statement meets a contract, namely S |= cr par C if and only if [[S]] cr \u2286 [[C]",
            "latex": null,
            "type": "figure"
        },
        "FIGREF3": {
            "text": "[[S even ]] cr if either s(n) < 0, or s(n) = 0 and s = s[r \u2192 1], or else s (r) = 1",
            "latex": null,
            "type": "figure"
        },
        "FIGREF4": {
            "text": "For a mapping h : A \u2192 B and set A \u2286 A, let h |A denote as usual the restriction of h on A . Definition 6 (Contract environment). A component m is an environment for contract c iff, for any implementation m of c, m and m are composable, and \u2200\u03c1",
            "latex": null,
            "type": "figure"
        },
        "FIGREF5": {
            "text": "Contract refinement). A contract c refines contract c , denoted c c , iff \u03c1 \u2212 c \u03c1 \u2212 c and \u03c1 + c \u03c1 + c ,where is the partial order relation defined in Section 3.1.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF6": {
            "text": "where and are the lub and glb operations of the lattice, respectively.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF7": {
            "text": "Induced contract). Let c be a denotational contract. It induces the contract C c = (E c , M c ), where E c def = {m \u2208 M | m is an environment for c} and M c def = {m \u2208 M | m |= c}.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF8": {
            "text": "For any two disjoint sets of procedures P + 1 and P + 2 , abstracted individually into components m 1 and m 2 , respectively, and P + 1 \u222a P + 2 abstracted into component m, it holds that m 1 \u00d7 m 2 = m.",
            "latex": null,
            "type": "figure"
        },
        "FIGREF9": {
            "text": "\u2212 does not really depend on \u03c1 + . Then, for any\u03c1 \u2212 \u2208 Env {odd} , (s, s ) \u2208 m(\u03c1 \u2212 )(even) if either s(n) = 0 and s = s[r \u2192 1], or else if s(n) > 0 and (s[n \u2192 s(n)\u22121], s ) \u2208 \u03c1 \u2212 (odd ).Similarly, the procedure set {odd } is abstracted into component m odd :Env {even} \u2192 Env {odd} with interface ({even}, {odd}), so that \u2200\u03c1 \u2212 \u2208 Env {even} . m(\u03c1 \u2212 )(odd ) = [[S odd ]] \u03c1\u2212 . Then, for any \u03c1 \u2212 \u2208 Env {even} , (s, s ) \u2208 m(\u03c1 \u2212 )(odd ) if either s(n) = 0 and s = s[r \u2192 0], or else if s(n) > 0 and (s[n \u2192 s(n) \u2212 1], s ) \u2208 \u03c1 \u2212 (even",
            "latex": null,
            "type": "figure"
        },
        "FIGREF10": {
            "text": "From Hoare logic contracts to denotational contracts). For a procedure p with Hoare logic contract C p , calling other procedures P \u2212 , we define the denotational contract c p = (\u03c1 \u2212 cp , \u03c1 + cp ) with interface P + cp def = {p} and P \u2212 cp def = P \u2212 , so that \u03c1 + cp (p) def = \u03c1 c (p), and \u2200p \u2208 P \u2212 . \u03c1 \u2212 cp (p ) = \u03c1 c (p ).",
            "latex": null,
            "type": "figure"
        },
        "TABREF0": {
            "text": "Properties that hold in theories that adhere to the meta-theory.",
            "latex": null,
            "type": "table"
        },
        "TABREF1": {
            "text": "denotation of a statement S, denoted [[S]], is typically given as a partial function State \u2192 State such that [[S]] (s) = s whenever executing statement S from the initial state s terminates in state s . In case that executing S from s does not terminate, the value of [[S]] (s) is undefined. The definition of [[S]] proceeds by induction on the structure of S. For example, the meaning of sequential composition of statements is usually captured with relation composition, as given by the equation [[S 1 ; S 2",
            "latex": null,
            "type": "table"
        },
        "TABREF2": {
            "text": "Component abstraction example. Let us illustrate the theorem on our even-odd example (however, the example does not really illustrate Beki\u0107's Lemma, since the two procedures do not call themselves).By Definition 12, the procedure set {even} is abstracted into component m even :Env {odd} \u2192 Env {even} with interface ({odd}, {even}), so that \u2200\u03c1 \u2212 \u2208 Env {odd} . m(\u03c1 \u2212 )(even) = [[S even ]] \u03c1 \u2212 . By definition, [[S even ]] \u03c1 \u2212 is equal to [[S even ]] \u03c1 \u2212 , where \u03c1 + 0 is the least fixed point of \u03be : Env {even} \u2192 Env {even} defined by \u03be(\u03c1 + )(even) def = [[S even ]] \u03c1 + \u03c1 \u2212 for any \u03c1 + \u2208 Env {even} . Notice, however, that procedure even does not have any calls to itself, so [[S even ]]",
            "latex": null,
            "type": "table"
        },
        "TABREF3": {
            "text": "). Now, applying Definition 12 to the whole (closed) program yields a component m :Env \u2205 \u2192 Env {even,odd } with interface (\u2205, {even, odd }), so that \u2200\u03c1 \u2212 \u2208 Env \u2205 . \u2200p \u2208 {even, odd } . m(\u03c1 \u2212 )(p) = [[S p ]] \u03c1 \u2212 . Recall the denotations [[S even ]] \u03c1 \u2212 and [[S odd ]] \u03c1 \u2212 from the end of Section 3.1.Components m even and m odd are composable, and by Definition 3, their composition has (the same) interface (\u2205, {even, odd }), and is (also) a mapping m even \u00d7 m odd : Env \u2205 \u2192 Env {even,odd } .Finally, note that function \u03c7 + meven \u00d7m odd : Env {even,odd } \u2192 Env {even,odd } is exactly the function \u03be in the context of the interface(\u2205, {even, odd }). This can be seen by first noting that since Env \u2205 = \u2205, we have that \u03c7 +meven \u00d7m odd only depends on its arguments. Furthermore, for all \u03c1 + \u2208 Env {even,odd } , if \u03c1 + odd def = \u03c1 + {odd} and \u03c1 + even def = \u03c1 + {even} we have that, since odd \u2208 P \u2212 even \u2229 P + odd , then \u03c7 + meven \u00d7m odd (\u03c1 + )(even) = m even (\u03c1 + odd )(even) = [[S even ]] \u03c1 + odd = [[S even ]]",
            "latex": null,
            "type": "table"
        }
    },
    "back_matter": []
}